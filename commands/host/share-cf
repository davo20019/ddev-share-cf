#!/usr/bin/env bash

## Description: Share your DDEV site publicly via Cloudflare Tunnel
## Usage: share-cf
## Example: "ddev share-cf"

#ddev-generated

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Shared Variables ---
DDEV_LOCALHOST_URL="http://127.0.0.1:${DDEV_HOST_HTTP_PORT}"
TUNNEL_URL=""

# Function to run the Dockerized tunnel approach (Fallback method)
run_docker_tunnel() {
    echo -e "${YELLOW}âš ï¸ Host binary 'cloudflared' not found. Falling back to Dockerized service...${NC}"

    # --- 1. Start the cloudflared service (or ensure it's running) ---
    echo -e "${BLUE}ðŸš€ Starting/Ensuring Cloudflare Tunnel Docker service is running...${NC}"

    # Check if the service is NOT running (or not yet defined).
    if ! ddev describe --json-output 2>/dev/null | grep -q '"service_name": "cloudflared", "status": "running"'; then
        # We run a full 'ddev start' to reliably ensure all services, including the newly defined 'cloudflared' service,
        # are created and running, which is the most compatible approach across DDEV versions.
        echo -e "${YELLOW}Service not running. Running ${BLUE}ddev start${YELLOW} to initialize/start all services...${NC}"
        ddev start > /dev/null 2>&1 || {
            echo -e "${RED}âŒ Failed to start DDEV project or 'cloudflared' service.${NC}"
            echo -e "${YELLOW}Please check your DDEV configuration and run ${BLUE}ddev restart${YELLOW} manually.${NC}"
            exit 1
        }
    fi
    echo -e "${GREEN}âœ… Cloudflare Tunnel service is active.${NC}"

    # --- 2. Fetch the public URL from the logs ---
    echo -e "${YELLOW}â³ Generating and fetching public URL from Docker logs (this may take a few seconds)...${NC}"

    # Check the logs for up to 30 seconds
    for i in {1..30}; do
        # Search the last 20 lines of the cloudflared container logs for the URL
        LOG_OUTPUT=$(ddev logs -s cloudflared --tail 20 2>/dev/null)
        TUNNEL_URL=$(echo "$LOG_OUTPUT" | grep -oE 'https://[a-zA-Z0-9-]+\.trycloudflare\.com')

        if [ -n "$TUNNEL_URL" ]; then
            break
        fi
        sleep 1
    done

    if [ -z "$TUNNEL_URL" ]; then
        echo -e "${RED}âŒ Failed to find Cloudflare Tunnel URL in Docker logs after 30 seconds.${NC}"
        echo -e "${YELLOW}Check the logs manually: ${BLUE}ddev logs -s cloudflared${NC}"
        exit 1
    fi

    # --- 3. Output success and instructions ---
    echo ""
    echo -e "${GREEN}âœ… Tunnel Endpoint Found (via Docker)!${NC}"
    echo -e "${CYAN}ðŸŒ Public URL: ${YELLOW}${TUNNEL_URL}${NC}"
    echo ""
    echo -e "${YELLOW}ðŸ’¡ Tip: To view the live logs, run: ${BLUE}ddev logs -s cloudflared -f${NC}"
    echo "---"
}

# Function to run the host binary approach (Preferred method)
run_host_tunnel() {
    echo -e "${GREEN}âœ… Host binary 'cloudflared' found.${NC}"
    echo -e "${BLUE}ðŸš€ Starting Cloudflare Tunnel via host binary...${NC}"
    echo -e "${YELLOW}â³ Generating public URL (this may take a few seconds)...${NC}"
    echo ""
    echo -e "${CYAN}ðŸ“ Local site: ${DDEV_LOCALHOST_URL}${NC}"
    echo ""
    echo -e "${YELLOW}ðŸ’¡ Tip: Press Ctrl+C to stop the tunnel${NC}"
    echo "---"

    # Start the tunnel pointing to the DDEV site's host URL
    # This command blocks until Ctrl+C is pressed.
    cloudflared tunnel --url "${DDEV_LOCALHOST_URL}"
}

# Function to display site-specific fix instructions
display_site_fixes() {
    if [ -z "$TUNNEL_URL" ]; then
        # If running the host binary, the URL isn't immediately available in a variable
        # We can't display the custom instructions, so we just show generic ones.
        echo ""
        echo -e "${CYAN}â„¹ï¸ Site-Specific Fixes (Check your URL in the output above):${NC}"
        TUNNEL_PLACEHOLDER="https://your-tunnel-url.trycloudflare.com"
    else
        # If running Docker, the URL is set, so we use it for specific instructions
        echo ""
        echo -e "${CYAN}â„¹ï¸ Site-Specific Fixes:${NC}"
        TUNNEL_PLACEHOLDER="${TUNNEL_URL}"
    fi

    # Detect Drupal multisite setup
    SITES_PHP_PATH=""
    if [ -f "web/sites/sites.php" ]; then
        SITES_PHP_PATH="web/sites/sites.php"
    elif [ -f "docroot/sites/sites.php" ]; then
        SITES_PHP_PATH="docroot/sites/sites.php"
    fi

    if [ -n "$SITES_PHP_PATH" ]; then
        echo -e "${CYAN}  Drupal multisite detected.${NC}"
        echo -e "    ${YELLOW}ðŸ“ Note: Add the tunnel URL to ${SITES_PHP_PATH}${NC}"
        echo -e "    ${YELLOW}   Example: \$sites['${TUNNEL_PLACEHOLDER##*/}'] = 'subsite';${NC}"
    fi

    # Detect WordPress installation
    if [ "$DDEV_PROJECT_TYPE" = "wordpress" ]; then
        echo -e "${CYAN}  WordPress detected.${NC}"
        echo -e "    ${YELLOW}âš ï¸  Note: WordPress redirects may use the local domain instead of tunnel URL${NC}"
        echo -e "    ${YELLOW}   To fix, update URLs after tunnel starts (run in a separate terminal):${NC}"
        echo -e "    ${BLUE}ddev wp option update home '${TUNNEL_PLACEHOLDER}'${NC}"
        echo -e "    ${BLUE}ddev wp option update siteurl '${TUNNEL_PLACEHOLDER}'${NC}"
    fi

    # Detect Magento installation
    if [ "$DDEV_PROJECT_TYPE" = "magento" ] || [ "$DDEV_PROJECT_TYPE" = "magento2" ]; then
        echo -e "${CYAN}  Magento detected.${NC}"
        echo -e "    ${YELLOW}âš ï¸  Note: Magento redirects may use the local domain instead of tunnel URL${NC}"
        echo -e "    ${YELLOW}   To fix, update base URLs after tunnel starts (run in a separate terminal):${NC}"
        echo -e "    ${BLUE}ddev exec bin/magento config:set web/unsecure/base_url '${TUNNEL_PLACEHOLDER}/'${NC}"
        echo -e "    ${BLUE}ddev exec bin/magento config:set web/secure/base_url '${TUNNEL_PLACEHOLDER}/'${NC}"
        echo -e "    ${BLUE}ddev exec bin/magento cache:flush${NC}"
    fi
    echo ""
}

# --- Main Execution Flow ---

# 0. Initial Project Check
if [ -z "$DDEV_HOST_HTTP_PORT" ]; then
    echo -e "${RED}âŒ DDEV project is not running.${NC}"
    echo -e "${YELLOW}Please run ${BLUE}ddev start${YELLOW} first.${NC}"
    exit 1
fi

# 1. PRIORITY: Check for host binary
if command -v cloudflared &> /dev/null; then
    # Binary found: Execute host tunnel
    # Display fixes BEFORE starting the tunnel since the tunnel command blocks
    display_site_fixes
    run_host_tunnel
else
    # Binary not found: Execute Docker fallback
    run_docker_tunnel
    # Display fixes AFTER the docker run because the URL is now known in $TUNNEL_URL
    display_site_fixes
fi

# The script only reaches this point if the host tunnel (run_host_tunnel) was used and then stopped (Ctrl+C).
if command -v cloudflared &> /dev/null; then
    echo -e "${YELLOW}Cloudflare Tunnel stopped.${NC}"
fi
